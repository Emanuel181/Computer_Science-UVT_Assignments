#include<stdio.h>
#include <stdlib.h>


#define max(a,b) \
   ({ __typeof__ (a) _a = (a); \
       __typeof__ (b) _b = (b); \
     _a > _b ? _a : _b; })
#define min(a,b) \
   ({ __typeof__ (a) _a = (a); \
       __typeof__ (b) _b = (b); \
     _a > _b ? _b : _a; })

typedef struct node {
    int key;
    int h_l;
    int h_r;
    int on_left;
    struct node* left;
    struct node* right;
    struct node* parent;
} node;
typedef struct tree {
    node* root;
} tree;


node* neww(int k, node* p, int bl){
    node* x = (node*)malloc(sizeof(node));
    x->key = k;
    x->left = NULL;
    x->right = NULL;
    x->parent = p;
    x->on_left = bl;
    x->h_l = 0;
    x->h_r = 0;
    //if(p != NULL)p->len += x->len;
    return x;
}

void ll_rotation(tree *a, node *n){ 
      /*n este nodul care nu e balansat in arbore se va insera cheia 7 */
    //   printf("ll rotation pe : %d\n", n->key);
    //   printf("Inainte de rotatie:\n"); preorder(a->root); printf("\n");
        node* L = neww(0, NULL, 0);
        node* LR = neww(0, NULL, 0);
        node* P = neww(0, NULL, 0);

        L = n->right;
        LR = n->right->left;
        P = n->parent;

        // printf("L = %d\n", L->key);
        // if(LR != NULL){
        //     printf("LR = %d\n", LR->key);
        // }

        n->right = LR;
        n->h_r = 0;
        if(LR != NULL){
            n->h_r = max(LR->h_l, LR->h_r) + 1;
            LR->parent = n;
            LR->on_left = 0;
        }

        L->left = n;
        L->h_l = max(n->h_l, n->h_r) + 1;
        n->parent = L;

        if(n->on_left == 1){

            P->left = L;
            P->h_l = max(L->h_l, L->h_r) + 1; 
            L->parent = P;
            L->on_left = 1;
        }else
        if(n->on_left == 0){

            P->right = L;
            P->h_r = max(L->h_l, L->h_r) + 1; 
            L->parent = P;
            L->on_left = 0;
        }

        n->on_left = 1;

        //preorder(a->root); printf("\n");

}

void rr_rotation(tree *a, node *n){
      /*n este nodul care nu e balansat in arbore se va insera cheia 10 iar apoi 12 */
       //printf("rr rotation pe : %d\n", n->key); 
       //printf("Inainte de rotatie:\n"); preorder(a->root); printf("\n");
        node* L = neww(0, NULL, 0);
        node* LR = neww(0, NULL, 0);
        node* P = neww(0, NULL, 0);

        L = n->left;
        LR = n->left->right;
        P = n->parent;

        n->left = LR;
        n->h_l = 0;
        if(LR != NULL){
            n->h_r = max(LR->h_l, LR->h_r) + 1;
            LR->parent = n;
            LR->on_left = 1;
        }

        L->right = n;
        L->h_r = max(n->h_l, n->h_r) + 1;
        n->parent = L;
        

        if(n->on_left == 1){

            P->left = L;
            P->h_l = max(L->h_l, L->h_r) + 1; 
            L->parent = P;
            L->on_left = 1;
        }else
        if(n->on_left == 0){

            P->right = L;
            P->h_r = max(L->h_l, L->h_r) + 1; 
            L->parent = P;
            L->on_left = 0;
        }

        n->on_left = 0;
        //preorder(a->root); printf("\n");
}

void left_right_rotation(tree *a, node *n){
      /*n este nodul care nu e balansat */
        //printf("Facem LR pe nodul = %d\n", n->key);
       ll_rotation(a, n->left);
        //printf("Am facut L pe nodul = %d\n", n->key);
       rr_rotation(a, n);
    //printf("Am facut R pe nodul = %d\n", n->key);
}
void right_left_rotation(tree *a, node *n){
      /*n este nodul care nu e balansat  */
       rr_rotation(a, n->right);
       ll_rotation(a, n);
}


void add(tree *a, node *x, int k){
    if(k > (x->key)){
        if(x->right != NULL){
            add(a, x->right,  k);
            x->h_r = max(x->right->h_l, x->right->h_r) + 1;
        }else{
            x->right = neww(k, x, 0);
            x->h_r = 1;
            return;
        }
    }else{
        if(x->left != NULL){
            add(a, x->left,  k);
            x->h_l = max(x->left->h_l, x->left->h_r) + 1;
        }else{
            x->left = neww(k, x, 1);
            x->h_l = 1;
            return;
        }
    }

    //printf("N = %d\n", x->key);

    if(x->left != NULL){
        //printf("L = %d h_l = %d h_r = %d\n", x->left->key, x->left->h_l, x->left->h_r);
        x->h_l = max(x->left->h_l, x->left->h_r) + 1;
    }
    if(x->right != NULL){
        //printf("R = %d h_l = %d h_r = %d\n", x->right->key, x->right->h_l, x->right->h_r);
        x->h_r = max(x->right->h_l, x->right->h_r) + 1;
    }
    
    //echilibrare
    if(x->h_l - x->h_r > 1){
        //printf("Left dezechilibru la nodul = %d\n", x->key);
        if(x->left->h_l < x->left->h_r){
            //printf("Left-right dezechilibru la nodul = %d\n", x->key);
            left_right_rotation(a, x);
            return;
        }else rr_rotation(a, x);
        return;
    }else
    if(x->h_r - x->h_l > 1){
        //printf("Right dezechilibru la nodul = %d\n", x->key);
        if(x->right->h_r < x->right->h_l){
            right_left_rotation(a, x);
        }else ll_rotation(a, x);
    }
}

void insert(tree *a, int k){
    if(a->root == NULL){
        a->root = neww(k, NULL, -1);
        return;
    }

    add(a, a->root, k);
}

int rs;

void fnd_l(node* x, int bl){
    if(x->left == NULL && x->right == NULL){
        int ans = x->key;
        if(bl == 1)
                x->parent->left = NULL;
        if(bl == 0)
                x->parent->right = NULL;
        free(x);
        rs = ans;
        return;
    }
    
    if(x->right != NULL)
        fnd_l(x->right, 0);
    else
        fnd_l(x->left, 1);

    if(x->left != NULL)
        x->h_l = max(x->left->h_l, x->left->h_r) + 1;
    if(x->right != NULL)
        x->h_r = max(x->right->h_l, x->right->h_r) + 1;
}

void fnd_r(node* x, int bl){
    if(x->left == NULL && x->right == NULL){
        int ans = x->key;
        if(bl == 1){
                x->parent->left = NULL;
                x->parent->h_l = 0;
        }else
        if(bl == 0){
                x->parent->right = NULL;
                x->parent->h_r = 0;
        }
        free(x);
        rs = ans;
        return;
    }
    
    if(x->left != NULL)
        fnd_r(x->right, 0);
    else
        fnd_r(x->left, 1);

    if(x->left != NULL)
        x->h_l = max(x->left->h_l, x->left->h_r) + 1;
    if(x->right != NULL)
        x->h_r = max(x->right->h_l, x->right->h_r) + 1;
}

void dlt(node* x, int k, int bl){
    if(x->key == k){
        if(x->left == NULL && x->right == NULL){
            if(bl == 1){
                x->parent->left = NULL;
                x->parent->h_l = 0;
            }else
            if(bl == 0){
                x->parent->right = NULL;
                x->parent->h_r = 0;
            }
            free(x);
            return;
        }
        if(x->left != NULL)fnd_l(x->left, bl);else fnd_r(x->right, bl);
        x->key = rs;
        return;
    }

    if((k > (x->key)) && (x->right != NULL))dlt(x->right, k, 0);
    if((k < (x->key)) && (x->left != NULL))dlt(x->left, k, 1);
    
    if(x->left != NULL){
        x->h_l = max(x->left->h_l, x->left->h_r) + 1;
    }
    if(x->right != NULL){
        x->h_l = max(x->left->h_l, x->left->h_r) + 1;
    }
}

void delete(tree *a, int v){
    dlt(a->root, v, 3);
}